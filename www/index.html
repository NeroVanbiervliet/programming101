<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="UTF-8">
    <title>Programming 101</title>

    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
    <link rel="stylesheet" href="assets/css/main.css">
    <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/default.min.css">
    <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
</head>
<body>
<aside>
    <nav data-type="toc" class="toc" id="toc"></nav>
</aside>
<main>
    <h1>Programming 101</h1>

    <p>Programming101 presents a collection of articles that each explain a computer science topic by building an
        executable toy version. Hence, the focus is always understandability over completeness.</p>

    <p>The first part tackles <em>programming languages</em>. Foremost because it covers by background and education,
        but also because it form the basics for further articles. When we build a <em>relational database</em> in Part
        II we will want to use <em>SQL</em> to query it. Well, SQL is a <em>domain specific programming language</em>
        (DSL) which will need a parser and an interpreter...</p>

    <div data-type="part" class="part" id="part01">
        <h1>Part I : Programming Languages</h1>

        <section data-type="chapter" id="p01:intro">
            <h1>Intro</h1>

            <p>In Part I: Programming Languages we will be building an extremely simple programming language from the
                ground up. The goal is to turn a sequence of characters, the <em>source code</em> into a useful
                computation.</p>

            <p>A first step, is to turn source code into a sequence of tokens, much like humans can detect sentences in
                a text and words in a sentence. This is called lexing and is done by a lexer (<a href="#p01:lexing">see
                    lexing</a>).</p>

            <p>A second step is to turn the sequence of tokens into an <em>abstract syntax tree</em> (AST), much like
                humans expect a question (sentence) to be followed by an answer (sentence) or expect a sentence to at
                least contain a subject (word or words) and a predicate (word or words). This is called parsing and is
                done by a parser (<a href="#p01:parsing">see parsing</a>).</p>

            <p>The third step depends on the kind of language.From an execution point of view, there are two kinds of
                languages: <em>interpreted languages</em> and <em>compiled languages</em>. An interpreted language uses
                an <em>interpreter</em> to directly perform the computation (<a href="#p01:interpretation">see
                    interpretation</a>). A compiled language relies on a <em>compiler</em> to create new (executable)
                code (<a href="#p01:compilation">see compiling</a>). Both, the interpreter and the compiler needs to get
                their hands on an abstract syntax tree (AST).</p>

            <figure>
                <figcaption>From source code to code execution.</figcaption>
                <img src="assets/media/pl-flow.svg" alt="From source code to code execution."/>
            </figure>


            <p>The programming language we will be building is very simple. It has only two (first-class) data types:
                strings and integers. Every program consists of a bunch (zero or more) <em>function-definitions</em>,
                followed by a single <em>expression</em>, and ends with a single <code>;</code>. This is shown in <em>The
                    Grammar of our toy programming language.</em> Everything between <code>"</code> is to interpreted as
                literal text. <code>*</code>, <code>?</code>, and <code>|</code> are to be interpreted as <em>zero or
                    more times</em>, <em>zero or one time</em>, <em>either the one or the other (or)</em>, respectively.
                Finally, <code>[ - ]</code> denotes a range, e.g., any small letter can be written as
                <code>["a"-"z"]</code>. All other constructs are called <em>non-terminals</em> and need to be looked up
                in the grammar. <code>block</code>, for instance, is defined as <code>"{" statement* "}"</code>: zero or
                more statements surrounded by curly braces, a <code>statement</code> can be either of 5 options, ...
            </p>
            <figure>
                <figcaption>The Grammar of our toy programming language.</figcaption>
                <pre>
<code class="plaintext"
      data-src="https://raw.githubusercontent.com/madewael/programming101/5fb94ba8635ba2b144b2b581909bbecd677f858a/programming-languages/TheToyLanguage.g4">
</code>
                </pre>
            </figure>

        </section>

        <section data-type="chapter" id="p01:lexing">
            <h1>Lexing</h1>
            <p>In computer science, a <em>lexer</em> is a program that converts a sequence of characters into a sequence
                of tokens. Each token is a part of the original sequence to which the lexer assigns a meaning. For our
                toy programming language we will want to start with writing a lexer. This lexer will convert a sequence
                of characters into <em>symbols</em>, <em>keywords</em>, <em>literals</em>, and <em>identifiers</em>. At
                the same time, our lexer will ignore all white space.</p>

            <p>The main data structure we will be using in lexing (and in parsing) is the <code>Queue</code>.</p>.
            <figure>
                <figcaption>A simple implementation of queue, to expose common lexing/parsing terminology .</figcaption>
                <pre>
<code class="javascript"
      data-src="https://raw.githubusercontent.com/madewael/programming101/e687160475630e13c5fb157534827dd714bf9c9d/programming-languages/Queue.js">
</code>
</pre>
            </figure>

            <p>In our first iteration the lexer will not support symbols with a length larger than 1 (e.g.,
                <code>==</code>), or string literals. We add this functionality in a second pass. If we consider the
                grammar with theses simplifications we obtain the following symbols: <code>; , ( ) = { } + - * / % &lt;
                    &gt; !</code>. Any of these symbols is always a token because they are not supposed to appear any
                where else: not in keywords, not in integers, not in identifiers. The same holds for whitespaces <code>\t</code>,
                <code>\n</code>, and <code>\r</code>, but these are also ignored.</p>

            <p>The general approach for this simple lexer is to consume all characters from the input sequence <em>one
                by one</em>, hence the use of a queue. We accumulate all these characters into the <em>next token</em>.
                When we encounter either a symbol, a whitespace, or the end of the file (<code>EOF</code>), we know we
                processed a complete token and we remember it. If we just encountered a symbol, we need to remember this
                symbol as well.</p>

            <figure>
                <figcaption>The auxiliary data structure <code>TokenBuffer</code> is used to keep track of all processed
                    tokens, and the token currently being processed.
                </figcaption>
                <pre>
<code class="javascript"
      data-src="https://raw.githubusercontent.com/madewael/programming101/f87dbe6c83fc7e1a072c637df6d390c7f9643ec7/programming-languages/TokenBuffer.js">
</code>
</pre>
            </figure>

            <figure>
                <figcaption>The function <code>lex</code> processes characters one by one.</figcaption>
                <pre>
<code class="javascript"
      data-from="27"
      data-to="45"
      data-src="https://raw.githubusercontent.com/madewael/programming101/8ef35ac44c6f607df3457116a0e0a85b365caa68/programming-languages/lexer.js">
</code>
</pre>
            </figure>

            <figure>
                <figcaption>The function <code>determineTokenType</code> decides whether a string can be interpreted as
                    a <em>keyword</em>, a <em>integer</em>, or a <em>identifier</em>.
                </figcaption>
                <pre>
<code class="javascript"
      data-from="17"
      data-to="25"
      data-src="https://raw.githubusercontent.com/madewael/programming101/8ef35ac44c6f607df3457116a0e0a85b365caa68/programming-languages/lexer.js">
</code>
</pre>
            </figure>

            <figure>
                <figcaption>The predicates for <em>keyword</em>, a <em>whitespace</em>, or a <em>identifier</em> are
                    simple.
                </figcaption>
                <pre>
<code class="javascript"
      data-from="5"
      data-to="15"
      data-src="https://raw.githubusercontent.com/madewael/programming101/8ef35ac44c6f607df3457116a0e0a85b365caa68/programming-languages/lexer.js">
</code>
</pre>
            </figure>

            <figure>
                <figcaption>The output of lexing a simple example program.</figcaption>
                <pre>
                    <code class="javascript"
                          data-src="https://raw.githubusercontent.com/madewael/programming101/4576c842baaf504017b85df6c5b492d9d6b4e5d6/programming-languages/demo-programs/func.tpl">
                    </code>
                </pre>
            </figure>

            <p>When we pass the source code of the mini program above into our <code>lex</code> function, we get the
                following result.</p>

            <figure>
                <figcaption>The output of lexing a simple example program (see above).</figcaption>
                <pre><code class="javascript">
[ Token { type: 'keyword', value: 'function' },
  Token { type: 'identifier', value: 'foo' },
  Token { type: 'symbol', value: '(' },
  Token { type: 'identifier', value: 'a' },
  Token { type: 'symbol', value: ',' },
  Token { type: 'identifier', value: 'b' },
  Token { type: 'symbol', value: ')' },
  Token { type: 'symbol', value: '{' },
  Token { type: 'keyword', value: 'return' },
  Token { type: 'identifier', value: 'a' },
  Token { type: 'symbol', value: '+' },
  Token { type: 'identifier', value: 'b' },
  Token { type: 'symbol', value: ';' },
  Token { type: 'symbol', value: '}' },
  Token { type: 'identifier', value: 'foo' },
  Token { type: 'symbol', value: '(' },
  Token { type: 'integer', value: 1 },
  Token { type: 'symbol', value: ',' },
  Token { type: 'integer', value: 2 },
  Token { type: 'symbol', value: ')' },
  Token { type: 'symbol', value: ';' } ]
                </code></pre>
            </figure>

            <h2>Extending the Lexer</h2>

            <p>You can continue reading here if you want the expand the functionality of the lexer a bit more. We
                will be adding extra keywords which requires almost no work. We will add support for symbols that
                consist of more than one character, which will take a bit more effort. And finally we will add
                support for string literals, which will prove to be the most difficult endeavour of the three. If you
                want to get your first programming language up, and more importantly, running as soon as possible,
                you should skip this section and continue reading about <a href="#p01:parsing">parsing</a>.</p>
        </section>

        <section data-type="chapter" id="p01:parsing">
            <h1>Parsing</h1>
            <p> The main job of a parser is to turn the sequence of tokens into a more structured representation
                which is called the <em>abstract syntax tree</em> (AST). While doing so, the parser verifies whether
                the input has a correct structure, i.e., checking if the input matches the grammar.</p>

            <p>As state above, the input of a parser is a sequence of tokens. The result should be an AST that
                represents the full program. The main function <code>parse</code> turns the sequence of tokens into a
                queue of tokens and delegates to the dedicated parser <code>parseProgram</code>. For now the
                dedicated parser <code>parseProgram</code> does not do much, except show the structure of all
                dedicated parsers. Each dedicated parser accepts a queue and returns a structure that matches one of
                the grammar rules. Here, we parse a program, hence we expect a bunch of <em>function definitions</em>
                (zero, one, or more) and a single <em>expression</em>. Each program ends with a <code>;</code> but
                that is not of any meaning in an AST. Hence the name <em>abstract</em> syntax tree, not all concrete
                syntax elements need to be included, only those that still matter. In the concrete syntax the <code>;
                </code> is needed to detect the end of the expression. What remains is to implement functions that
                can parse (lists) of function definitions, that can parse expressions, and that can parse a <code>;
                </code>.</p>


            <figure>
                <figcaption>The main function <code>parse</code> and the dedicated parser <code>parseProgram</code>.
                </figcaption>
                <pre>
                    <code class="javascript"
                          data-from="3"
                          data-to="15"
                          data-src="https://raw.githubusercontent.com/madewael/programming101/a23d28cbb3e7d9cec71a6f67af8c62454693389d/programming-languages/parser.js"></code>
                </pre>
            </figure>


            <p>We updated our <code>Queue</code> to throw an error whenever <code>peek</code> or
                <code>consume</code> is called on an empty queue. The code can be seen <a
                        href="https://github.com/madewael/programming101/blob/2b7a1d6945ea63b2eea318cb2697491bca8c047a/programming-languages/Queue.js">here</a>.
                Because the update is trivial, the new version is omitted from the main text.</p>

            <p>A more important update is that of the dedicated parser <code>parseProgram</code> which now delegates
                its work to an auxiliary parser and two dedicated parsers: <code>parseFunctionDefinitionList</code>,
                <code>parseExpression </code>, and <code>parseSemicolon</code>, respectively. Then, it combines the
                results into a new AST node that represents the complete program. Not that the expected semicolon is
                effectively parsed, but it is ignored afterwards. Finally, we check if the queue is empty, if not, we
                have found an illegal program and we throw a parse error.</p>

            <figure>
                <figcaption>The the dedicated parser <code>parseProgram</code> delegates its work and produces an
                    AST-node for the complete program.
                </figcaption>
                <pre>
                    <code class="javascript"
                          data-from="9"
                          data-to="24"
                          data-src="https://raw.githubusercontent.com/madewael/programming101/2b7a1d6945ea63b2eea318cb2697491bca8c047a/programming-languages/parser.js"></code>
                </pre>
            </figure>

            <p>For now, an implementation for <code>parseFunctionDefinitionList</code> is omitted. Hence, only
                programs without any functions are accepted. This is, if <code>parseExpression</code> where to be
                implemented completely. We again limit ourselves here, and only accept literal integer expressions.
                To do so, <code>parseExpression</code> delegates its work to <code>parseInteger</code>. This is our
                first fully functional dedicated parser: a literal integer expression always consists of exactly one
                lexer token, and it has to be of type <code>integer</code>. If this is the case, we transform the lexer
                token in an AST node of type <code>integer</code>. The value we assign to this node is the value we
                obtain, from the token. Conceptually this is a big step, in practice almost nothing changes here.
                Finally, it is important to note that out (dedicated) parser <em>throws a parse error</em>. When you
                want (or need) to parse an integer and you find something else, it is useless for <em>this
                    (dedicated) parser</em> to continue. We will see later how en when we can recover from parse errors.
            </p>

            <figure>
                <figcaption>The dedicated parser <code>parseInteger</code>.</figcaption>
                <pre>
                    <code class="javascript"
                          data-from="34"
                          data-to="43"
                          data-src="https://raw.githubusercontent.com/madewael/programming101/2b7a1d6945ea63b2eea318cb2697491bca8c047a/programming-languages/parser.js"></code>
                </pre>
            </figure>

        </section>

        <section data-type="chapter" id="p01:interpretation">
            <h1>Interpretation</h1>
        </section>

        <section data-type="chapter" id="p01:compilation">
            <h1>Compilation</h1>
        </section>
    </div>
</main>
<script src="assets/js/index.js"></script>
</body>
</html>