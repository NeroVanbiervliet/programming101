<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="UTF-8">
    <title>Programming 101</title>

    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
    <link rel="stylesheet" href="assets/css/main.css">
    <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/default.min.css">
    <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
</head>
<body>
<aside>
    <nav data-type="toc" class="toc" id="toc"></nav>
</aside>
<main>
    <h1>Programming 101</h1>

    <p>Programming101 presents a collection of articles that each explain a computer science topic by building an
        executable toy version. Hence, the focus is always understandability over completeness.</p>

    <p>The first part tackles <em>programming languages</em>. Foremost because it covers by background and education,
        but also because it form the basics for further articles. When we build a <em>relational database</em> in Part
        II we will want to use <em>SQL</em> to query it. Well, SQL is a <em>domain specific programming language</em>
        (DSL) which will need a parser and an interpreter...</p>

    <div data-type="part" class="part" id="part01">
        <h1>Part I : Programming Languages</h1>

        <section data-type="chapter" id="p01:intro">
            <h1>Intro</h1>

            <p>In Part I: Programming Languages we will be building an extremely simple programming language from the
                ground up. The goal is to turn a sequence of characters, the <em>source code</em> into a useful
                computation.</p>

            <p>A first step, is to turn source code into a sequence of tokens, much like humans can detect sentences in
                a text and words in a sentence. This is called lexing and is done by a lexer (<a href="#p01:lexing">see
                    lexing</a>).</p>

            <p>A second step is to turn the sequence of tokens into an <em>abstract syntax tree</em> (AST), much like
                humans expect a question (sentence) to be followed by an answer (sentence) or expect a sentence to at
                least contain a subject (word or words) and a predicate (word or words). This is called parsing and is
                done by a parser (<a href="#p01:parsing">see parsing</a>).</p>

            <p>The third step depends on the kind of language.From an execution point of view, there are two kinds of
                languages: <em>interpreted languages</em> and <em>compiled languages</em>. An interpreted language uses
                an <em>interpreter</em> to directly perform the computation (<a href="#p01:interpretation">see
                    interpretation</a>). A compiled language relies on a <em>compiler</em> to create new (executable)
                code (<a href="#p01:compilation">see compiling</a>). Both, the interpreter and the compiler needs to get
                their hands on an abstract syntax tree (AST).</p>

            <figure>
                <figcaption>From source code to code execution.</figcaption>
                <img src="assets/media/pl-flow.svg" alt="From source code to code execution."/>
            </figure>


            <p>The programming language we will be building is very simple. It has only two (first-class) data types:
                strings and integers. Every program consists of a bunch (zero or more) <em>function-definitions</em>,
                followed by a single <em>expression</em>, and ends with a single <code>;</code>. This is shown in <em>The
                    Grammar of our toy programming language.</em> Everything between <code>"</code> is to interpreted as
                literal text. <code>*</code>, <code>?</code>, and <code>|</code> are to be interpreted as <em>zero or
                    more times</em>, <em>zero or one time</em>, <em>either the one or the other (or)</em>, respectively.
                Finally, <code>[ - ]</code> denotes a range, e.g., any small letter can be written as
                <code>["a"-"z"]</code>. All other constructs are called <em>non-terminals</em> and need to be looked up
                in the grammar. <code>block</code>, for instance, is defined as <code>"{" statement* "}"</code>: zero or
                more statements surrounded by curly braces, a <code>statement</code> can be either of 5 options, ...
            </p>
            <figure>
                <figcaption>The Grammar of our toy programming language.</figcaption>
                <pre>
<code class="plaintext"
      data-src="https://raw.githubusercontent.com/madewael/programming101/5fb94ba8635ba2b144b2b581909bbecd677f858a/programming-languages/TheToyLanguage.g4">
</code>
                </pre>
            </figure>

        </section>

        <section data-type="chapter" id="p01:lexing">
            <h1>Lexing</h1>
            <p>In computer science, a <em>lexer</em> is a program that converts a sequence of characters into a sequence
                of tokens. Each token is a part of the original sequence to which the lexer assigns a meaning. For our
                toy programming language we will want to start with writing a lexer. This lexer will convert a sequence
                of characters into <em>symbols</em>, <em>keywords</em>, <em>literals</em>, and <em>identifiers</em>. At
                the same time, our lexer will ignore all white space.</p>

            <p>The main data structure we will be using in lexing (and in parsing) is the <code>Queue</code>.</p>.
            <figure>
                <figcaption>A simple implementation of queue, to expose common lexing/parsing terminology .</figcaption>
                <pre>
<code class="javascript"
      data-src="https://raw.githubusercontent.com/madewael/programming101/e687160475630e13c5fb157534827dd714bf9c9d/programming-languages/Queue.js">
</code>
</pre>
            </figure>

            <p>In our first iteration the lexer will not support symbols with a length larger than 1 (e.g.,
                <code>==</code>), or string literals. We add this functionality in a second pass. If we consider the
                grammar with theses simplifications we obtain the following symbols: <code>; , ( ) = { } + - * / % &lt;
                    &gt; !</code>. Any of these symbols is always a token because they are not supposed to appear any
                where else: not in keywords, not in integers, not in identifiers. The same holds for whitespaces <code>\t</code>,
                <code>\n</code>, and <code>\r</code>, but these are also ignored.</p>

            <p>The general approach for this simple lexer is to consume all characters from the input sequence <em>one
                by one</em>, hence the use of a queue. We accumulate all these characters into the <em>next token</em>.
                When we encounter either a symbol, a whitespace, or the end of the file (<code>EOF</code>), we know we
                processed a complete token and we remember it. If we just encountered a symbol, we need to remember this
                symbol as well.</p>

            <figure>
                <figcaption>The auxiliary data structure <code>TokenBuffer</code> is used to keep track of all processed
                    tokens, and the token currently being processed.
                </figcaption>
                <pre>
<code class="javascript"
      data-src="https://raw.githubusercontent.com/madewael/programming101/f87dbe6c83fc7e1a072c637df6d390c7f9643ec7/programming-languages/TokenBuffer.js">
</code>
</pre>
            </figure>

            <figure>
                <figcaption>The function <code>lex</code> processes characters one by one.</figcaption>
                <pre>
<code class="javascript"
      data-from="27"
      data-to="45"
      data-src="https://raw.githubusercontent.com/madewael/programming101/8ef35ac44c6f607df3457116a0e0a85b365caa68/programming-languages/lexer.js">
</code>
</pre>
            </figure>

            <figure>
                <figcaption>The function <code>determineTokenType</code> decides whether a string can be interpreted as
                    a <em>keyword</em>, a <em>integer</em>, or a <em>identifier</em>.
                </figcaption>
                <pre>
<code class="javascript"
      data-from="17"
      data-to="25"
      data-src="https://raw.githubusercontent.com/madewael/programming101/8ef35ac44c6f607df3457116a0e0a85b365caa68/programming-languages/lexer.js">
</code>
</pre>
            </figure>

            <figure>
                <figcaption>The predicates for <em>keyword</em>, a <em>whitespace</em>, or a <em>identifier</em> are
                    simple.
                </figcaption>
                <pre>
<code class="javascript"
      data-from="5"
      data-to="15"
      data-src="https://raw.githubusercontent.com/madewael/programming101/8ef35ac44c6f607df3457116a0e0a85b365caa68/programming-languages/lexer.js">
</code>
</pre>
            </figure>

            <figure>
                <figcaption>The output of lexing a simple example program.</figcaption>
                <pre>
                    <code class="javascript"
                          data-src="https://raw.githubusercontent.com/madewael/programming101/4576c842baaf504017b85df6c5b492d9d6b4e5d6/programming-languages/demo-programs/func.tpl">
                    </code>
                </pre>
            </figure>

            <p>When we pass the source code of the mini program above into our <code>lex</code> function, we get the
                following result.</p>

            <figure>
                <figcaption>The output of lexing a simple example program (see above).</figcaption>
                <pre><code class="javascript">
[ Token { type: 'keyword', value: 'function' },
  Token { type: 'identifier', value: 'foo' },
  Token { type: 'symbol', value: '(' },
  Token { type: 'identifier', value: 'a' },
  Token { type: 'symbol', value: ',' },
  Token { type: 'identifier', value: 'b' },
  Token { type: 'symbol', value: ')' },
  Token { type: 'symbol', value: '{' },
  Token { type: 'keyword', value: 'return' },
  Token { type: 'identifier', value: 'a' },
  Token { type: 'symbol', value: '+' },
  Token { type: 'identifier', value: 'b' },
  Token { type: 'symbol', value: ';' },
  Token { type: 'symbol', value: '}' },
  Token { type: 'identifier', value: 'foo' },
  Token { type: 'symbol', value: '(' },
  Token { type: 'integer', value: 1 },
  Token { type: 'symbol', value: ',' },
  Token { type: 'integer', value: 2 },
  Token { type: 'symbol', value: ')' },
  Token { type: 'symbol', value: ';' } ]
                </code></pre>
            </figure>

            <h2>Extending the Lexer</h2>

            <p>You can continue reading here if you want the expand the functionality of the lexer a bit more. We
                will be adding extra keywords which requires almost no work. We will add support for symbols that
                consist of more than one character, which will take a bit more effort. And finally we will add
                support for string literals, which will prove to be the most difficult endeavour of the three. If you
                want to get your first programming language up, and more importantly, running as soon as possible,
                you should skip this section and continue reading about <a href="#p01:parsing">parsing</a>.</p>
        </section>

        <section data-type="chapter" id="p01:parsing">
            <h1>Parsing</h1>
            <p> The main job of a parser is to turn the sequence of tokens into a more structured representation
                which is called the <em>abstract syntax tree</em> (AST). While doing so, the parser verifies whether
                the input has a correct structure, i.e., checking if the input matches the grammar.</p>

            <p>As state above, the input of a parser is a sequence of tokens. The result should be an AST that
                represents the full program. The main function <code>parse</code> turns the sequence of tokens into a
                queue of tokens and delegates to the dedicated parser <code>parseProgram</code>. For now the
                dedicated parser <code>parseProgram</code> does not do much, except show the structure of all
                dedicated parsers. Each dedicated parser accepts a queue and returns a structure that matches one of
                the grammar rules. Here, we parse a program, hence we expect a bunch of <em>function definitions</em>
                (zero, one, or more) and a single <em>expression</em>. Each program ends with a <code>;</code> but
                that is not of any meaning in an AST. Hence the name <em>abstract</em> syntax tree, not all concrete
                syntax elements need to be included, only those that still matter. In the concrete syntax the <code>;
                </code> is needed to detect the end of the expression. What remains is to implement functions that
                can parse (lists) of function definitions, that can parse expressions, and that can parse a <code>;
                </code>.</p>


            <figure>
                <figcaption>The main function <code>parse</code> and the dedicated parser <code>parseProgram</code>.
                </figcaption>
                <pre>
                    <code class="javascript"
                          data-from="3"
                          data-to="15"
                          data-src="https://raw.githubusercontent.com/madewael/programming101/a23d28cbb3e7d9cec71a6f67af8c62454693389d/programming-languages/parser.js"></code>
                </pre>
            </figure>


            <p>We updated our <code>Queue</code> to throw an error whenever <code>peek</code> or
                <code>consume</code> is called on an empty queue. The code can be seen <a
                        href="https://github.com/madewael/programming101/blob/2b7a1d6945ea63b2eea318cb2697491bca8c047a/programming-languages/Queue.js">here</a>.
                Because the update is trivial, the new version is omitted from the main text.</p>

            <p>A more important update is that of the dedicated parser <code>parseProgram</code> which now delegates
                its work to an auxiliary parser and two dedicated parsers: <code>parseFunctionDefinitionList</code>,
                <code>parseExpression </code>, and <code>parseSemicolon</code>, respectively. Then, it combines the
                results into a new AST node that represents the complete program. Not that the expected semicolon is
                effectively parsed, but it is ignored afterwards. Finally, we check if the queue is empty, if not, we
                have found an illegal program and we throw a parse error.</p>

            <figure>
                <figcaption>The the dedicated parser <code>parseProgram</code> delegates its work and produces an
                    AST-node for the complete program.
                </figcaption>
                <pre>
                    <code class="javascript"
                          data-from="9"
                          data-to="24"
                          data-src="https://raw.githubusercontent.com/madewael/programming101/2b7a1d6945ea63b2eea318cb2697491bca8c047a/programming-languages/parser.js"></code>
                </pre>
            </figure>

            <p>For now, an implementation for <code>parseFunctionDefinitionList</code> is omitted. Hence, only
                programs without any functions are accepted. This is, if <code>parseExpression</code> where to be
                implemented completely. We again limit ourselves here, and only accept literal integer expressions.
                To do so, <code>parseExpression</code> delegates its work to <code>parseInteger</code>. This is our
                first fully functional dedicated parser: a literal integer expression always consists of exactly one
                lexer token, and it has to be of type <code>integer</code>. If this is the case, we transform the lexer
                token in an AST node of type <code>integer</code>. The value we assign to this node is the value we
                obtain, from the token. Conceptually this is a big step, in practice almost nothing changes here.
                Finally, it is important to note that out (dedicated) parser <em>throws a parse error</em>. When you
                want (or need) to parse an integer and you find something else, it is useless for <em>this
                    (dedicated) parser</em> to continue. We will see later how en when we can recover from parse errors.
            </p>

            <figure>
                <figcaption>The dedicated parser <code>parseInteger</code>.</figcaption>
                <pre>
                    <code class="javascript"
                          data-from="34"
                          data-to="43"
                          data-src="https://raw.githubusercontent.com/madewael/programming101/a145897865dbd4f3605e9b60b8dfe7770f2c20b2/programming-languages/parser.js"></code>
                </pre>
            </figure>

            <p>The implementation for the dedicated parser <code>parseSemicolon</code> is if possible even more
                simple: we consume the next token and verify its type and value. Here, we expect it to the symbol
                <code>;</code>. If this is not the case, we encountered a parse error, hence the <code>throw</code>.
                We return the token, however this is not strictly necessary. As you can imagine, this kind of
                dedicated parser will have to be written for each and every <em>symbol</em> and <em>keyword</em>.
                Hence, we will move the logic to the <code>Token</code>, which will simplify the parsers a bit.
            </p>

            <figure>
                <figcaption>The dedicated parser <code>parseSemicolon</code>.</figcaption>
                <pre>
                    <code class="javascript"
                          data-from="45"
                          data-to="51"
                          data-src="https://raw.githubusercontent.com/madewael/programming101/a145897865dbd4f3605e9b60b8dfe7770f2c20b2/programming-languages/parser.js"></code>
                </pre>
            </figure>

            <p>We add two functions to our <code>Tokens</code>:<code>is</code> and <code>ensure</code>. <code>
                is</code> will be limited to <em>checking</em> whether a tokens is of the expected type and value,
                whereas <code>ensure</code> will also <em>enforce</em> the expected condition by throwing a parse
                error is the conditions are not met. Moreover, we make the expected value optional, which will
                prove to come in handy as well... In the remainder of this text we will omit explicit references to
                the simple dedicated parsers, i.e., the parsers for keywords and symbols.</p>

            <figure>
                <figcaption>Simplified <code>parseInteger</code> and <code>parseSemicolon</code>.</figcaption>
                <pre>
                    <code class="javascript"
                          data-from="34"
                          data-to="45"
                          data-src="https://raw.githubusercontent.com/madewael/programming101/c5df4d392da4d75b7bd77ed04d986fa92b8ad932/programming-languages/parser.js"></code>
                </pre>
            </figure>


            <p>We now focus on our function definitions that may or may not precede the expression. In order the
                parse a bunch of these definitions, we need to be able to at least parse one such function definition.
                Hence, we need the dedicated parser <code>parseFunctionDefinition</code>. It very much resembles the
                dedicated parser <code>parseProgram</code>, in that is a straightforward translation from the grammar
                rule to executable code. The actual parsing of the parameter list and the body is delegated to the
                dedicated parsers <code>parseParamList</code> and <code>parseBlock</code>, respectively.
            </p>

            <figure>
                <figcaption>The dedicated parser <code>parseFunctionDefinition</code> is a straightforward
                    translation from the grammar rule.
                </figcaption>
                <pre>
                    <code class="javascript"
                          data-from="35"
                          data-to="48"
                          data-src="https://raw.githubusercontent.com/madewael/programming101/382ea1d87b2b064c9078ee10ce9676c334b1c864/programming-languages/parser.js"></code>
                </pre>
            </figure>

            <p>In their current implementations, <code>parseParamList</code> and <code>parseBlock</code> accept
                anything between the first open and close brackets it encounters (round or curly), they ignore the
                actual structure and return a simple list of un-parsed tokens. Hence, the only way to make them fail
                is by having an open bracket that is never closed. In this case the queue will run out of tokens and
                trow a parse error.</p>

            <figure>
                <figcaption><code>parseParamList</code> and <code>parseBlock</code> return the list of tokens between
                    a set of brackets.
                </figcaption>
                <pre>
                    <code class="javascript"
                          data-from="35"
                          data-to="48"
                          data-src="https://raw.githubusercontent.com/madewael/programming101/382ea1d87b2b064c9078ee10ce9676c334b1c864/programming-languages/parser.js"></code>
                </pre>
            </figure>

            <p>The grammar, however, states that programs with a list of these function
                definitions. Hence, we could use <code>parseFunctionDefinition</code> to parse the first such
                definition and return it as an element is a list. If there is no function definition, the parse would
                fail because it expects to find the keyword <code>function</code> but will find an <code>integer</code>
                token. We therefore wrap our code in a <code>try-catch</code>-block to recover from an
                <em>more or less expected parse error</em>. When our parser reaches the catch block, we know the
                code does not start with a proper function definition, hence it should start parsing the expression,
                hence, the list of functions is empty.</p>

            <figure>
                <figcaption>Parse a zero or one function definitions and return them as a list.
                </figcaption>
                <pre>
                    <code class="javascript"
                          data-from="26"
                          data-to="33"
                          data-src="https://raw.githubusercontent.com/madewael/programming101/382ea1d87b2b064c9078ee10ce9676c334b1c864/programming-languages/parser.js"></code>
                </pre>
            </figure>

            <p>When we run our current parser of some demo programs, we see that it works fine for programs that
                have exactly one function definition followed by a literal integer as expression. However, we expected
                our parser to also accept the programs it accepted before, i.e., the programs that cosnist of a
                single literal integer without any functions. We observe, however, that parsing this integer fails.
                Even though we know the program is correct, we still get the following error: <em>Parse error:
                    expected a integer but got a symbol.</em> The parse error thus occurs during the execution of
                <code>parseInteger</code>, <code>parseFunctionDefinition</code> and <code>parseFunctionDefinitionList
                </code> worked fine.</p>

            <p>So ... what went wrong? The problem with our dedicated parsers is that they
                manipulate the queue. In programs that do not start with a function definition, we do <code>try</code>
                to parse a function definition. When it fails, we return an empty list and continue to try and parse
                an integer literal. Trying to parse the non-existing function definition, however, consumed the first
                token from the queue: the integer. Because <code>parseFunctionDefinition</code> expected the keyword
                <code>function</code> but received an <code>integer</code>-token, it fails fast. While <code>
                    parseFunctionDefinitionList</code> is made to recover from this expected parse error, the harm is
                already doe: the queue was changed and the integer was consumed, and is never to be found again.</p>

            <p>A possible solution to this problem is to anticipate the destruction of the queue in those cases
                where a parse error is to be expected. If we where to copy the contents of the queue before parsing,
                and restore the queue to its original state if a parser error would occur, all would be fine. This is
                realised by <code>tryParse</code>: it expects a (dedicated) parser and a queue and behaves exactly
                as if the parser would have been called with the queue directly, i.e., <em>return</em> an AST node or
                <em>throw</em> a parse error. When an AST node is returned, the queue will have changed.
                In the case a parse error is thrown, however, the queue will be seemingly untouched.</p>

            <figure>
                <figcaption><code>tryParse</code> restores the contents of the queue in the case of a
                    (parse) error during parsing.
                </figcaption>
                <pre>
                    <code class="javascript"
                          data-from="3"
                          data-to="11"
                          data-src="https://raw.githubusercontent.com/madewael/programming101/7497bd2b3ecaa808be7d2e6e0ccb38661644351c/programming-languages/parser.js"></code>
                </pre>
            </figure>

            <p>We can now update <code>parseFunctionDefinitionList</code> such that it accepts any number of
                function definitions, by trying to parse them in an infinite loop. When we exit the loop, we know
                the last function definition has been successfully parsed, and the queue is restored to the state
                right after this last function definition.</p>

            <figure>
                <figcaption><code>tryParse</code> restores the contents of the queue in the case of a
                    (parse) error during parsing.
                </figcaption>
                <pre>
                    <code class="javascript"
                          data-from="36"
                          data-to="46"
                          data-src="https://raw.githubusercontent.com/madewael/programming101/f37a8f257feb72ccfb364fd79c90a7e574cddf45/programming-languages/parser.js"></code>
                </pre>
            </figure>


        </section>

        <section data-type="chapter" id="p01:interpretation">
            <h1>Interpretation</h1>
        </section>

        <section data-type="chapter" id="p01:compilation">
            <h1>Compilation</h1>
        </section>
    </div>
</main>
<script src="assets/js/index.js"></script>
</body>
</html>